选定要整理100条路线数，选定遗传算法的限制。
旅行商问题要解决路线最优的问题，因此要用迭代次数100000若2000次最优路线未被代替来限制方案的跳出。
提前准备数据。

dist_matrix[i,j]表示的是城市到城市j的距离
提取出每个城市的与其他城市的距离存放到二维数组中。
距离计算采用的是勾股定理。
这里利用了数据的内容为每个城市的二维坐标。

routes存放所有的初始化路线。为二维数组，行代表路线数目，列代表长度为127的路线选择。
这里利用了numpy产生随机数的函数。
np.random.choice(range(n_cities), size=n_cities, replace=False)
在range的范围内产生size大小的数列。replace=False代表无重复的值

fitness_values存放每个路线的适应度。二维数组。行代表路线数目，列代表适应度。
适应度为每一种路线的距离的倒数。生成数组后，存取最优下标，最优路线，及其适应度

遗传算法三大基本操作：选择，交叉，变异

1.选择：计算出每一条路线的与适应性相关的概率，
choice = np.random.choice(range(n_routes), p=probability) #概率越大，取值次数越多
利用numpy 的随机函数的特性来生成新的路线数据
这里的选择是以路线为单位的。

2.交叉：在路线中顺序选出两条路线，数据切分执行再合并操作
in1d函数会返回布尔值。若表二的元素在比表一有的话，则会返回对值；是单个元素的判断
利用了numpy的特性，选出交叉值的列表，插入到对应值的列表，在合成

3.变异：numpy随机数生成小数与设定突变概率进行比较，成则在路线内及进行选取两位置的数值交换























